Network Layer: Control
Network Layer: 5-2
Network layer control plane: our
goalsunderstand principles behind
network control plane:
• Network-wide logic that
controls how a datagram is
routed
• Network components/services
are configured and managed
• Begin with an overview of
traditional routing algorithms
• Least cost path in a graph
 implementation in the
Internet:
• OSPF, BGP
• OpenFlow, ODL and ONOS
controllers
• Internet Control Message
Protocol: ICMP
• SNMP, YANG/NETCONF
Network layer: “control plane”
roadmap
 network management,
configuration
• SNMP
• NETCONF/YANG
 introduction
 routing protocols
 link state
 distance vector
 intra-ISP routing: OSPF
 routing among ISPs: BGP
 SDN control plane
 Internet Control Message
Protocol
Network Layer: 5-3
Network Layer: 5-4
Network-layer
functions
• Accomplished using forwarding/flow tables
• Generalized forwarding: Not only forward a packet to
output port, but also drop, replicate, and re-write
packet headers
 routing: determine route taken by packets
from source to destination
Recall:
 forwarding: move packets from router’s input
port to appropriate router output port
• How forwarding tables are constructed, maintained, and installed
Two approaches to structuring network control plane:
 per-router control (traditional)
 logically centralized control (software defined networking)
data plane
control plane
Per-router control
• A routing algorithm runs in each and every router
• Forwarding and routing functionality is in each router
Routing
Algorithm
data
plane
control
plane
1
2
0111
values in arriving
packet header
Network Layer: 5-5
3
• Each router has a routing
component that
communicates with other
routing components in other
routers.
• These calculations are used
to update individual
forwarding tables
• The traditional approach: Used in
the internet for decades
Software-Defined Networking (SDN) control
plane
data
plane
control
plane
Remote Controller
CA
CA CA CA CA
1
2
0111
3
packet header
• Remote controller computes, installs forwarding tables in routers
• The controller interacts
with a Control Agent in
each router.
• The control agent has
minimum functionality
Network Layer: 5-6
• Communicate with
values in arriving
the remote
controller and issue
its commands.
Software-Defined Networking (SDN) control
plane• Controller agents don’t directly interact with each other or
data
plane
control
plane
Remote Controller
CA
CA CA CA CA
1
2
0111
3
values in arriving
packet header
Network Layer: 5-7
calculate forwarding tables
• Functionality that is
typically provided by
middleboxes (NAT, load
sharing, firewalling) can
now be logically
centralized.
• Physically implemented
via multiple servers for
fault-tolerance
Network layer: “control plane”
roadmap
 network management,
configuration
• SNMP
• NETCONF/YANG
 introduction
 routing protocols
 link state
 distance vector
 intra-ISP routing: OSPF
 routing among ISPs: BGP
 SDN control plane
 Internet Control Message
Protocol
Network Layer: 5-8
Routing protocol goal: determine
“good” paths (equivalently, routes),
from sending hosts to receiving host,
through network of routers
 path: sequence of routers packets
traverse from given initial source host
to final destination host
 “good”: least “cost”, “fastest”, “least
congested”
 We also need to consider policy
issues such as avoiding routers
owned by another organization
Routing
protocols mobile network
enterprise
network
national or global ISP
datacenter
network
application
transport
network
link
physical
application
transport
network
link
physical
network
link
physical
network
link
physical
network
link
physical
network
link
physical network
link
physical
Network Layer: 5-9
Graph abstraction: link
costs
u
Network Layer: 5-10
yx
wv
z
2
2
1
3
1
1
2
5
3
5
A graph: G = (N,E) consists of N nodes and E edges
• N: set of routers = { u, v, w, x, y, z }
• E: set of links ={ (u,v), (u,x), (v,x), (v,w), (x,w), (x,y), (w,y), (w,z), (y,z) }
• Note that a node can also
consist of an entire network
• A path in the graph G is a sequence of
nodes (x1, x2, x3, ... xn ) such that each of
the pairs, (x1, x2), (x2, x3)... (xn-1, xn) are
edges in E
Graph abstraction: link costs
u
Network Layer: 5-11
yx
wv
z
2
2
1 3
1
1
2
5
3
5
• For our purposes, we’ll take the edge costs as given (we’re not
concerned with how they are generated)
• Each edge in the network can have a cost associated with it:
• Cost could be physical, monetary, temporal
• For any edge denoted as (a,b), in the set E, we denote C(a,b)
as the cost of the edge between nodes a and b.
• If a pair (a,b) does not belong to E, then we set that that
particular cost to infinity:
e.g.,
cw,z = 5, cu,z = ∞
• We will only consider undirected graphs, so that C(a,b) =
c(b,a)
• The cost of a path is the sum of the edge costs: c
(x1, x2)+ c(x2, x3)+... +c(xn-1, xn)
Center for Applied Internet Data Analysis
(CAIDA) Center for Applied Internet Data Analysis is
a research organization based at the San
Diego Supercomputer Center, (UCSD) who’s
mission is to study the Internet’s
infrastructure, behavior, security, and
performance. It focuses on various aspects
of internet topology, traffic analysis, and
network dynamics to inform policy and
improve the understanding of global
internet infrastructure.
https://www.caida.org/projects/as-core/2020/#introduction
Network Layer: 5-12
Graph abstraction: link costs
u
Network Layer: 5-13
yx
wv
z
2
2
1 3
1
1
2
5
3
5
• We are not just interested in any path, specifically try to find the least
cost path.
• That is, to find the path between the source and destination that
minimizes c(x,y).
• E.g., The least cost path between u and w would be (u, x, y, w)
with a cost of c(u,w) = 3.
• Note that if all weights in G are equal, the least
cost path is equal to the shortest path
• Question: How would a human find the least
cost path from u to z?
Graph abstraction: link costs
u
Network Layer: 5-14
yx
wv
z
2
2
1 3
1
1
2
5
3
5
• The human begins by examining the figure and tracing a few routs
from u to z
• Probably not checking all 17 possibilities and convincing themself that
they have the optimal solution.
• This kind of “eyeballing” calculation is analogous to a centralized
routing algorithm
• centralized routing algorithm: runs in one
location (human brain) with complete information
about the network
Network Layer: 5-15
Routing algorithm
classification• There are two main categories of routing algorithms
Centralized: computes the least-cost path between a source and
destination using complete, global knowledge about the
network.
• Algorithms with complete knowledge of connectivity and
link cost are often called Link-state algorithms
Decentralized: least-cost path is calculated in an iterative,
distributed manner by the routers.
• No single node has complete information. Details of the
graph must be exchanged between each other.
• Referred to as distance-vector (DV) algorithm
Routing algorithm
classification
Network Layer: 5-16
• Routing loops
• Route oscillations
• A second way to classify routing algorithms:
Static: Static routing algorithms change very slowly over
time.
• Change is typically the result of human intervention.
• E.g., manually editing the link costs
Dynamic: Dynamic routing algorithms change the routing
paths as the network traffic loads or topology change.
• Can be run periodically or in direct response to a
change
• Susceptible to problems:
Network Layer: 5-17
Routing algorithm classification
• A third way to classify routing algorithms:
Load sensitive: Link costs vary dynamically to reflect the current
level of congestion in the underlying link.
• A high cost in a link indicates congestion
• Choose to route around that node
Load-insensitive: Today’s Internet routing algorithms (such as RIP,
OSPF, and BGP) are load-insensitive,
• A link’s cost does not explicitly reflect its current (or recent)
level of congestion.
Routing algorithm classification
global: all routers have complete
topology, link cost info
• “link state” algorithms
How fast
do routes
change?
dynamic: routes change
more quickly
• periodic updates or in
response to link cost
changes
decentralized: iterative process of
computation, exchange of info with neighbors
• routers initially only know link costs to
attached neighbors
• “distance vector” algorithms
global or decentralized information?
static: routes change
slowly over time
Network Layer: 5-18
Network layer: “control plane”
roadmap
 network management,
configuration
• SNMP
• NETCONF/YANG
 introduction
 routing protocols
 link state
 distance vector
 intra-ISP routing: OSPF
 routing among ISPs: BGP
 SDN control plane
 Internet Control Message
Protocol
Network Layer: 5-19
Dijkstra’s link-state routing algorithm
 centralized: network topology, link
costs are known to all nodes
• accomplished via “link state broadcast”
• Link-state packets containing the
identities and costs of it’s attached link
are sent to every node in the network
• all nodes have same info
 computes least cost paths from one
node (“source”) to all other nodes
• gives forwarding table for that node
 iterative: after k iterations, know least
cost path to k destinations
notation
 cx,y: direct link cost from
node x to y; = ∞ if not direct
neighbors
 D(v): current estimate of cost
of least-cost-path from source
to destination v
 p(v): predecessor node along
path from source to v
 N': set of nodes whose least-
cost-path definitively known
Network Layer: 5-20
Dijkstra’s link-state routing algorithm
Network Layer: 5-21
1 Initialization:
2 N' = {u}
3 for all nodes v
4 if v adjacent to u
5 then D(v) = cu,v
6 else D(v) = ∞
7
8 Loop
/* compute least cost path from u to all other nodes */
/* u initially knows direct-path-cost only to direct neighbors */
/* but may not be minimum cost! */
9
10
11
12
13
14
15 until all nodes in N'
find w not in N' such that D(w) is a minimum
add w to N'
update D(v) for all v adjacent to w and not in N' :
D(v) = min ( D(v), D(w) + cw,v )
/* new least-path-cost to v is either old least-cost-path to v or known
least-cost-path to w plus direct-cost from w to v */
Dijkstra’s algorithm: an example
Step
0
1
2
3
4
5
u
yx
wv
z
2
2
1 3
1
1
2
5
3
5
4,y
4,y3,y
5,u 1,u2,u
2,x4,x2,u ∞
4,y3,y2,u
uxyvw
uxyvwz
uxyv
uxy
ux
N'
u
v
D(v),p(v)
w
D(w),p(w)
x
D(x),p(x)
y z
D(y),p(y) D(z),p(z)
∞ ∞
find a not in N' such that D(a) is a minimum
add a to N'
update D(b) for all b adjacent to a and not in N' :
D(b) = min ( D(b), D(a) + ca,b )
Network Layer: 5-22
Initialization (step 0): For all a: if a adjacent to then D(a) = cu,a
Dijkstra’s algorithm: an example
u
yx
wv
z
2
2
1 3
1
1
2
5
3
5
D(w),p(w)
5,u
4,x
3,y
3,y
u
yx
z
resulting least-cost-path tree from u:
v w
resulting forwarding table in u:
destination outgoing link
v
x
y
w
z
(u,v)
(u,x)
(u,x)
(u,x)
(u,x)
route from u to v directly
route from u to all
other destinations
via x
• We have, for each node, its predecessor
Network Layer: 5-23
along the least-cost path from the source
node.
• For each predecessor, we also have its
predecessor, and so on...
• Can calculate forwarding table.
Dijkstra’s algorithm: another example
w3
4
v
x
u
5
3
7 4
y
8
z
2
7
9
Step N'
v w
D(v), D(w),
p(v) p(w)
0
1
2
3
4
5
x
D(x),
p(x)
y z
D(y), D(z),
p(y) p(z)
u
notes:
 construct least-cost-path tree by tracing predecessor nodes
 ties can exist (can be broken arbitrarily)
Network Layer: 5-24
Dijkstra’s algorithm: another example
w3
4
v
x
u
5
3
7 4
y
8
z
2
7
9
Step N'
0
1
2
3
4
5
∞∞u 7,u 3,u 5,u
uw ∞6,w 5,u 11,w
14,x11,w6,wuwx
uwxv 14,x10,v
uwxvy 12,y
uwxvyz
v w
D(v), D(w),
p(v) p(w)
x
D(x),
p(x)
y z
D(y), D(z),
p(y) p(z)
Network Layer: 5-25
Network Layer: 5-26
Dijkstra’s algorithm: discussion
algorithm complexity: Given n nodes
 each of n iteration: need to check all nodes, w, not in N
 n(n+1)/2 comparisons: O(n2) complexity
 more efficient implementations possible: O(nlogn)
message complexity:
 each router must broadcast its link state information to other n routers
 efficient (and interesting!) broadcast algorithms: O(n) link crossings to disseminate a
broadcast message from one source
 each router’s message crosses O(n) links: overall message complexity: O(n2)
Dijkstra’s algorithm: oscillations possible
 when link costs depend on traffic volume, route oscillations possible
 sample scenario:
• routing to destination a, traffic entering at d, c, b with rates 1, e (<1), 1
• link costs are directional, and volume-dependent
initially
given these costs,
find new routing....
resulting in new costs
given these costs,
find new routing....
resulting in new costs
1 a 1+e 2+e a 0 0 a 2+e 2+e a 0
1
d
0
0
c
0 b
e
1 1
d
0
1+e
c
1
0
b
1 1
d
1
0
c
0 b
1+e 1 1
d
0
1+e
c
1 b
0 1
e e e e
Network Layer: 5-27
given these costs,
find new routing....
resulting in new costs
Network layer: “control plane”
roadmap
 network management,
configuration
• SNMP
• NETCONF/YANG
 introduction
 routing protocols
 link state
 distance vector
 intra-ISP routing: OSPF
 routing among ISPs: BGP
 SDN control plane
 Internet Control Message
Protocol
Network Layer: 5-28
Network Layer: 5-29
Whereas the LS algorithm is an algorithm using global
information, the distance vector (DV) algorithm is distributed
, iterative, and asynchronous.
Distributed in that each node:
• receives some information from one or more of its directly attached
neighbors,
• performs a calculation,
• and then distributes the results of its calculation back to its
neighbors.
Iterative in that this process continues on until no more
information is exchanged between neighbors.
Distance vector
algorithmNetwork Layer: 5-29
Whereas the LS algorithm is an algorithm using global
information, the distance vector (DV) algorithm is distributed
, iterative, and asynchronous.
Distributed in that each node:
• receives some information from one or more of its directly attached
neighbors,
• performs a calculation,
• and then distributes the results of its calculation back to its
neighbors.
Iterative in that this process continues on until no more
information is exchanged between neighbors.
Distance vector
algorithm
Network Layer: 5-30
Whereas the LS algorithm is an algorithm using global
information, the distance vector (DV) algorithm is iterative,
asynchronous, and distributed.
Asynchronous in that it does not require all of the nodes to
operate in lockstep with each other
These kind of algorithms are also self-terminating—there is
no signal that the computation should stop; it just stops.
Distance vector
algorithm
Distance vector
algorithm
min taken over all neighbors v of x
Based on Bellman-Ford (BF) equation (dynamic programming):
The minimum cost from source x to destination y, then the
path must have one of x’s neighbors v as a first hop
Bellman-Ford equation
Let Dx(y): cost of least-cost path from x to y.
Then:
Dx(y) = minv { cx,v + Dv(y) }
v’s estimated least-cost-path cost to y
direct cost of link from x to v Network Layer: 5-31
Bellman-Ford
Example
u
y
z
2
2
1 3
1
1
2
5
3
5
Suppose that u’s neighboring nodes, x,v,w, know that for destination z:
Bellman-Ford equation says:
Du(z) = min { cu,v + Dv(z),
cu,x + Dx(z),
cu,w + Dw(z) }
= min {2 + 5,
1 + 3,
5 + 3} = 4
node achieving minimum (x) is
next hop on estimated least-
cost path to destination (z)
Dv(z) = 5
v
Dw(z) = 3
w
Dx(z) = 3
x
Network Layer: 5-32
Network Layer: 5-33
Distance vector
algorithmkey idea:
 from time-to-time, each node sends its own distance vector estimate
to neighbors
 when node x receives new DV e∀stimate from any neighbor, it updates
its own DV table using B-F equation:
Dx(y) ← minv{cx,v + Dv(y)} ∀ node y ∊ N
 The least-cost distance from node x to node y will be the minimum
cost from node x to all intermediary hops v plus the possible paths
from v to y.
Distance vector
algorithm: iterative, asynchronous: each local
iteration caused by:
 local link cost change
 DV update message from neighbor
distributed, self-stopping: each
node notifies neighbors only when
its DV changes
 neighbors then notify their
neighbors – only if necessary
 If no notification received, no
actions taken!
each node loop:
1 wait for (change in local link
cost or msg from neighbor)
2 recompute DV estimates
using DV received from
neighbor
3 If my DV to any destination
has changed, notify neighbors